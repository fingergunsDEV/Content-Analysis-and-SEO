<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Content Insight Engine</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Optional: Add custom styles here if needed, or rely solely on Tailwind */
        body {
            font-family: 'Inter', sans-serif;
        }
    </style>
</head>
<body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>

    <!-- Load React and ReactDOM Libraries from CDN -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <!-- Load Babel for JSX transpilation in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Load Firebase Libraries -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Expose Firebase objects globally for use in the Babel script
        window.firebaseApp = initializeApp(JSON.parse(__firebase_config));
        window.firebaseAuth = getAuth(window.firebaseApp);
        window.firebaseDb = getFirestore(window.firebaseApp);
        window.signInAnonymously = signInAnonymously;
        window.signInWithCustomToken = signInWithCustomToken;
        window.onAuthStateChanged = onAuthStateChanged;
        window.signOut = signOut;
        window.firebaseDoc = doc;
        window.firebaseGetDoc = getDoc;
        window.firebaseSetDoc = setDoc;

        // Make __app_id available globally
        window.__app_id = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // Custom token sign-in or anonymous sign-in
        window.onload = async () => {
            if (typeof __initial_auth_token !== 'undefined') {
                try {
                    await window.signInWithCustomToken(window.firebaseAuth, __initial_auth_token);
                } catch (error) {
                    console.error("Error signing in with custom token:", error);
                    await window.signInAnonymously(window.firebaseAuth);
                }
            } else {
                await window.signInAnonymously(window.firebaseAuth);
            }
        };
    </script>


    <!-- Your React App Component (type="text/babel" is crucial for in-browser transpilation) -->
    <script type="text/babel">
        // Import React hooks from the global React object
        const { useState, useEffect } = React;

        // --- Helper Components ---

        const LoadingSpinner = () => (
            <div className="flex justify-center items-center h-full">
                <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-purple-500"></div>
                <p className="ml-4 text-gray-600">Loading application...</p>
            </div>
        );

        const ProfileScreen = ({ user, username, setUsername, setIsEditingProfile, saveUserProfile, handleSignOut, isSaving }) => (
            <div className="bg-white rounded-xl shadow-2xl p-8 space-y-6 max-w-md mx-auto">
                <h2 className="text-3xl font-bold text-purple-800 text-center mb-4">User Profile</h2>
                <div className="text-gray-700 text-lg">
                    <p className="mb-2"><span className="font-semibold">User ID:</span> {user.uid}</p>
                    <p className="mb-4"><span className="font-semibold">Current Username:</span> {username}</p>
                </div>
                <div className="flex flex-col space-y-4">
                    <label htmlFor="editUsername" className="block text-xl font-semibold text-gray-700">Edit Username:</label>
                    <input
                        id="editUsername"
                        type="text"
                        className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent transition duration-200 shadow-sm"
                        value={username}
                        onChange={(e) => setUsername(e.target.value)}
                        placeholder="Enter new username"
                    />
                    <button
                        onClick={saveUserProfile}
                        className={`w-full py-3 rounded-xl font-bold text-white transition-all duration-300 shadow-lg
                                    ${isSaving
                                    ? 'bg-gray-400 cursor-not-allowed'
                                    : 'bg-gradient-to-r from-green-500 to-teal-600 hover:from-green-600 hover:to-teal-700 transform hover:scale-105'
                                    }`}
                        disabled={isSaving}
                    >
                        {isSaving ? 'Saving...' : 'Save Profile'}
                    </button>
                    <button
                        onClick={() => setIsEditingProfile(false)}
                        className="w-full py-3 rounded-xl font-bold text-purple-700 border border-purple-700 hover:bg-purple-50 transition-colors duration-200 shadow-md"
                    >
                        Back to Analyzer
                    </button>
                    <button
                        onClick={handleSignOut}
                        className="w-full py-3 rounded-xl font-bold text-red-700 border border-red-700 hover:bg-red-50 transition-colors duration-200 shadow-md"
                    >
                        Sign Out
                    </button>
                </div>
            </div>
        );

        const AnalysisResultDisplay = ({ title, results, message, colorClass = "text-gray-700", bgColorClass = "bg-white" }) => (
            <div className={`mb-6 pb-4 border-b border-gray-200 ${bgColorClass} p-4 rounded-lg`}>
                <h3 className={`text-2xl font-semibold ${colorClass} mb-2`}>{title}</h3>
                {Object.entries(results).map(([key, value]) => {
                    if (Array.isArray(value)) {
                        return (
                            <div key={key} className="mt-2">
                                <p className="font-medium text-gray-700 capitalize">{key.replace(/([A-Z])/g, ' $1').trim()}:</p>
                                <ul className="list-disc list-inside text-gray-600 ml-4">
                                    {value.length > 0 ? value.map((item, index) => (
                                        <li key={index}>{item}</li>
                                    )) : <li>No specific items.</li>}
                                </ul>
                            </div>
                        );
                    } else if (typeof value === 'string' || typeof value === 'number') {
                        return <p key={key} className="text-gray-600"><span className="font-medium capitalize">{key.replace(/([A-Z])/g, ' $1').trim()}:</span> {value}</p>;
                    }
                    return null;
                })}
                <p className="text-gray-600 mt-1">{message}</p>
            </div>
        );

        // --- Main App Component ---
        const App = () => {
            // Core Application States
            const [textContent, setTextContent] = useState('');
            const [comparisonText, setComparisonText] = useState('');
            const [targetKeyword, setTargetKeyword] = useState('');
            const [analysisResults, setAnalysisResults] = useState(null);
            const [isLoading, setIsLoading] = useState(false);
            const [error, setError] = useState('');

            // Feature Toggle States
            const [enableCosineSimilarity, setEnableCosineSimilarity] = useState(false);
            const [enableWordEmbedding, setEnableWordEmbedding] = useState(false);
            const [enableLinguisticAnalytics, setEnableLinguisticAnalytics] = useState(false);
            const [enableContentAnalysis, setEnableContentAnalysis] = useState(false);
            const [enableComprehensionAnalysis, setEnableComprehensionAnalysis] = useState(false);
            const [enableSeoAnalysis, setEnableSeoAnalysis] = useState(false);
            const [enableBlendedAnalysis, setEnableBlendedAnalysis] = useState(false);
            const [enableForecasting, setEnableForecasting] = useState(false);
            const [enableCompetitiveGap, setEnableCompetitiveGap] = useState(false);

            // User & Auth States
            const [user, setUser] = useState(null);
            const [isAuthReady, setIsAuthReady] = useState(false);
            const [username, setUsername] = useState('Guest User');
            const [isEditingProfile, setIsEditingProfile] = useState(false);
            const [isSavingProfile, setIsSavingProfile] = useState(false);


            // Firebase Initialization and Auth State Listener
            useEffect(() => {
                if (window.firebaseAuth && window.onAuthStateChanged) {
                    const unsubscribe = window.onAuthStateChanged(window.firebaseAuth, async (currentUser) => {
                        setUser(currentUser);
                        if (currentUser) {
                            // Fetch user profile from Firestore
                            const userId = currentUser.uid;
                            const appId = window.__app_id;
                            const userProfileRef = window.firebaseDoc(window.firebaseDb, `artifacts/${appId}/users/${userId}/profile/userProfileDoc`);
                            const docSnap = await window.firebaseGetDoc(userProfileRef);

                            if (docSnap.exists()) {
                                setUsername(docSnap.data().username || 'Unnamed User');
                            } else {
                                // Create a basic profile if it doesn't exist
                                const defaultUsername = `User-${userId.substring(0, 6)}`;
                                await window.firebaseSetDoc(userProfileRef, { username: defaultUsername, createdAt: new Date() });
                                setUsername(defaultUsername);
                            }
                        } else {
                            setUsername('Guest User');
                        }
                        setIsAuthReady(true);
                    });
                    return () => unsubscribe(); // Cleanup subscription on unmount
                }
            }, []);

            // Save User Profile to Firestore
            const saveUserProfile = async () => {
                if (user) {
                    setIsSavingProfile(true);
                    try {
                        const userId = user.uid;
                        const appId = window.__app_id;
                        const userProfileRef = window.firebaseDoc(window.firebaseDb, `artifacts/${appId}/users/${userId}/profile/userProfileDoc`);
                        await window.firebaseSetDoc(userProfileRef, { username: username }, { merge: true });
                        alert('Profile saved successfully!'); // Replaced confirm with alert for consistency
                    } catch (err) {
                        console.error("Error saving profile:", err);
                        alert('Failed to save profile. Please try again.'); // Replaced confirm with alert
                    } finally {
                        setIsSavingProfile(false);
                    }
                }
            };

            // Handle user sign out
            const handleSignOut = async () => {
                try {
                    await window.signOut(window.firebaseAuth);
                    setTextContent(''); // Clear content on sign out
                    setComparisonText('');
                    setAnalysisResults(null);
                    setTargetKeyword('');
                    setUsername('Guest User');
                    setIsEditingProfile(false);
                    alert('You have been signed out.'); // Replaced confirm with alert
                } catch (error) {
                    console.error("Error signing out:", error);
                    alert('Error signing out. Please try again.'); // Replaced confirm with alert
                }
            };


            // Function to perform content analysis using Gemini API and client-side logic
            const performAnalysis = async () => {
                setIsLoading(true);
                setError('');
                setAnalysisResults(null);

                if (!textContent.trim()) {
                    setError("Please enter some content to analyze.");
                    setIsLoading(false);
                    return;
                }

                try {
                    const results = {};
                    const apiKey = ""; // Canvas will automatically provide the API key at runtime

                    // 1. Cosine Similarity (Client-side, Bag-of-Words)
                    if (enableCosineSimilarity) {
                        if (!comparisonText.trim()) {
                            results.cosineSimilarity = { score: 'N/A', message: 'Please provide comparison text for cosine similarity.' };
                        } else {
                            const similarityScore = calculateBagOfWordsSimilarity(textContent, comparisonText);
                            results.cosineSimilarity = {
                                score: `${similarityScore.toFixed(2)}%`,
                                message: `The bag-of-words similarity between your main content and comparison text is approximately ${similarityScore.toFixed(2)}%. For deeper semantic similarity, consider using a dedicated word embedding model.`
                            };
                        }
                    }

                    // 2. Word Embedding Analysis (via Gemini API for key terms and semantic summary)
                    let wordEmbeddingKeyTerms = 'N/A';
                    let wordEmbeddingSemanticSummary = 'N/A';
                    if (enableWordEmbedding) {
                        try {
                            const chatHistory = [];
                            chatHistory.push({ role: "user", parts: [{ text: `Analyze the following text for its core topics, key entities, and semantic insights. Provide a list of the top 5-7 key terms/phrases and a brief summary of the main semantic themes. Respond in JSON. Text: "${textContent}"` }] });
                            const payload = {
                                contents: chatHistory,
                                generationConfig: {
                                    responseMimeType: "application/json",
                                    responseSchema: {
                                        type: "OBJECT",
                                        properties: {
                                            "keyTerms": {
                                                type: "ARRAY",
                                                items: { "type": "STRING" }
                                            },
                                            "semanticSummary": { "type": "STRING" }
                                        },
                                        propertyOrdering: ["keyTerms", "semanticSummary"]
                                    }
                                }
                            };
                            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                            const response = await fetch(apiUrl, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload)
                            });
                            const result = await response.json();

                            if (result.candidates && result.candidates.length > 0 &&
                                result.candidates[0].content && result.candidates[0].content.parts &&
                                result.candidates[0].content.parts.length > 0) {
                                const json = result.candidates[0].content.parts[0].text;
                                const parsedJson = JSON.parse(json);
                                wordEmbeddingKeyTerms = parsedJson.keyTerms ? parsedJson.keyTerms.join(', ') : 'N/A';
                                wordEmbeddingSemanticSummary = parsedJson.semanticSummary || 'N/A';
                                results.wordEmbedding = {
                                    keyTerms: wordEmbeddingKeyTerms,
                                    semanticSummary: wordEmbeddingSemanticSummary,
                                    message: 'Key terms and semantic summary generated using Gemini API for word embedding analysis.'
                                };
                            } else {
                                results.wordEmbedding = { keyTerms: 'Error', semanticSummary: 'Error', message: 'Failed to get results from Gemini API.' };
                            }
                        } catch (apiError) {
                            console.error("Gemini API error for word embedding:", apiError);
                            results.wordEmbedding = { keyTerms: 'Error', semanticSummary: 'Error', message: `API Error: ${apiError.message}` };
                        }
                    }

                    // 3. Linguistic Analytics (via Gemini API for sentiment and complexity)
                    let linguisticSentiment = 'N/A';
                    let linguisticComplexityAssessment = 'N/A';
                    let linguisticComplexitySuggestions = 'N/A';
                    let linguisticAvgSentenceLength = 'N/A';
                    let linguisticAvgWordLength = 'N/A';

                    if (enableLinguisticAnalytics) {
                        try {
                            const chatHistory = [];
                            chatHistory.push({ role: "user", parts: [{ text: `Perform a linguistic analysis of the following text. Determine its overall sentiment (positive, negative, neutral) and provide an assessment of its linguistic complexity, including suggestions for making it more or less complex if needed. Respond in JSON. Text: "${textContent}"` }] });
                            const payload = {
                                contents: chatHistory,
                                generationConfig: {
                                    responseMimeType: "application/json",
                                    responseSchema: {
                                        type: "OBJECT",
                                        properties: {
                                            "sentiment": { "type": "STRING" },
                                            "complexityAssessment": { "type": "STRING" },
                                            "complexitySuggestions": { "type": "STRING" }
                                        },
                                        propertyOrdering: ["sentiment", "complexityAssessment", "complexitySuggestions"]
                                    }
                                }
                            };
                            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                            const response = await fetch(apiUrl, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload)
                            });
                            const result = await response.json();

                            if (result.candidates && result.candidates.length > 0 &&
                                result.candidates[0].content && result.candidates[0].content.parts &&
                                result.candidates[0].content.parts.length > 0) {
                                const json = result.candidates[0].content.parts[0].text;
                                const parsedJson = JSON.parse(json);

                                const { avgSentenceLength, avgWordLength } = performClientSideLinguisticAnalysis(textContent); // Keep client-side basic metrics
                                linguisticAvgSentenceLength = `${avgSentenceLength} words`;
                                linguisticAvgWordLength = `${avgWordLength.toFixed(1)} chars`;
                                linguisticSentiment = parsedJson.sentiment || 'N/A';
                                linguisticComplexityAssessment = parsedJson.complexityAssessment || 'N/A';
                                linguisticComplexitySuggestions = parsedJson.complexitySuggestions || 'N/A';

                                results.linguisticAnalytics = {
                                    avgSentenceLength: linguisticAvgSentenceLength,
                                    avgWordLength: linguisticAvgWordLength,
                                    sentiment: linguisticSentiment,
                                    complexityAssessment: linguisticComplexityAssessment,
                                    complexitySuggestions: linguisticComplexitySuggestions,
                                    message: 'Linguistic insights generated using Gemini API and client-side metrics.'
                                };
                            } else {
                                results.linguisticAnalytics = {
                                    avgSentenceLength: 'Error', avgWordLength: 'Error', sentiment: 'Error',
                                    complexityAssessment: 'Error', complexitySuggestions: 'Error',
                                    message: 'Failed to get results from Gemini API.'
                                };
                            }
                        } catch (apiError) {
                            console.error("Gemini API error for linguistic analytics:", apiError);
                            results.linguisticAnalytics = {
                                avgSentenceLength: 'Error', avgWordLength: 'Error', sentiment: 'Error',
                                complexityAssessment: 'Error', complexitySuggestions: 'Error',
                                message: `API Error: ${apiError.message}`
                            };
                        }
                    }

                    // 4. Content Analysis (Client-side, enhanced)
                    let contentWordCount = 0;
                    let contentSentenceCount = 0;
                    let contentParagraphCount = 0;
                    let contentReadabilityScore = 0;

                    if (enableContentAnalysis) {
                        const { wordCount, sentenceCount, paragraphCount, readabilityScore } = performContentAnalysis(textContent);
                        contentWordCount = wordCount;
                        contentSentenceCount = sentenceCount;
                        contentParagraphCount = paragraphCount;
                        contentReadabilityScore = readabilityScore;

                        results.contentAnalysis = {
                            wordCount: contentWordCount,
                            sentenceCount: contentSentenceCount,
                            paragraphCount: contentParagraphCount,
                            readabilityScore: `${contentReadabilityScore.toFixed(1)} (Flesch-Kincaid)`,
                            message: 'Basic content metrics and Flesch-Kincaid readability score calculated client-side.'
                        };
                    }

                    // 5. Comprehension Analysis (via Gemini API)
                    let comprehensionReadingLevel = 'N/A';
                    let comprehensionSuggestions = 'N/A';
                    if (enableComprehensionAnalysis) {
                        try {
                            const chatHistory = [];
                            chatHistory.push({ role: "user", parts: [{ text: `Analyze the following text for its reading comprehension level and identify any areas that might be difficult for a general audience. Provide an estimated reading level (e.g., 'Elementary', 'Middle School', 'High School', 'College', 'Professional') and specific suggestions for improving clarity and comprehension. Respond in JSON. Text: "${textContent}"` }] });
                            const payload = {
                                contents: chatHistory,
                                generationConfig: {
                                    responseMimeType: "application/json",
                                    responseSchema: {
                                        type: "OBJECT",
                                        properties: {
                                            "estimatedReadingLevel": { "type": "STRING" },
                                            "claritySuggestions": {
                                                type: "ARRAY",
                                                items: { "type": "STRING" }
                                            }
                                        },
                                        propertyOrdering: ["estimatedReadingLevel", "claritySuggestions"]
                                    }
                                }
                            };
                            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                            const response = await fetch(apiUrl, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload)
                            });
                            const result = await response.json();

                            if (result.candidates && result.candidates.length > 0 &&
                                result.candidates[0].content && result.candidates[0].content.parts &&
                                result.candidates[0].content.parts.length > 0) {
                                const json = result.candidates[0].content.parts[0].text;
                                const parsedJson = JSON.parse(json);
                                comprehensionReadingLevel = parsedJson.estimatedReadingLevel || 'N/A';
                                comprehensionSuggestions = parsedJson.claritySuggestions && parsedJson.claritySuggestions.length > 0 ? parsedJson.claritySuggestions.join('. ') : 'No specific suggestions.';
                                results.comprehensionAnalysis = {
                                    readingLevel: comprehensionReadingLevel,
                                    suggestions: comprehensionSuggestions,
                                    message: 'Reading level and comprehension suggestions generated using Gemini API.'
                                };
                            } else {
                                results.comprehensionAnalysis = { readingLevel: 'Error', suggestions: 'Error', message: 'Failed to get results from Gemini API.' };
                            }
                        } catch (apiError) {
                            console.error("Gemini API error for comprehension analysis:", apiError);
                            results.comprehensionAnalysis = { readingLevel: 'Error', suggestions: 'Error', message: `API Error: ${apiError.message}` };
                        }
                    }

                    // 6. SEO Analysis (Client-side keyword checks + Gemini API for comprehensive suggestions)
                    let seoKeywordDensity = 'N/A';
                    let seoKeywordPresence = 'N/A';
                    let seoSuggestionsCombined = [];

                    if (enableSeoAnalysis) {
                        const { keywordDensity, keywordPresence, clientSideSeoSug } = performSeoAnalysis(textContent, targetKeyword);
                        seoKeywordDensity = keywordDensity !== null ? `${keywordDensity.toFixed(2)}%` : 'N/A';
                        seoKeywordPresence = keywordPresence;
                        seoSuggestionsCombined.push(...clientSideSeoSug);

                        try {
                            const chatHistory = [];
                            chatHistory.push({ role: "user", parts: [{ text: `Based on the following content and target keyword "${targetKeyword}", provide advanced SEO optimization suggestions beyond basic keyword density. Focus on content structure, user intent, topical authority, and technical considerations. Respond in JSON with an array named 'advancedSeoSuggestions'. Content: "${textContent}"` }] });
                            const payload = {
                                contents: chatHistory,
                                generationConfig: {
                                    responseMimeType: "application/json",
                                    responseSchema: {
                                        type: "OBJECT",
                                        properties: {
                                            "advancedSeoSuggestions": {
                                                type: "ARRAY",
                                                items: { "type": "STRING" }
                                            }
                                        },
                                        propertyOrdering: ["advancedSeoSuggestions"]
                                    }
                                }
                            };
                            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                            const response = await fetch(apiUrl, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload)
                            });
                            const result = await response.json();

                            let advancedSeoSuggestions = [];
                            if (result.candidates && result.candidates.length > 0 &&
                                result.candidates[0].content && result.candidates[0].content.parts &&
                                result.candidates[0].content.parts.length > 0) {
                                const json = result.candidates[0].content.parts[0].text;
                                const parsedJson = JSON.parse(json);
                                advancedSeoSuggestions = parsedJson.advancedSeoSuggestions || [];
                            } else {
                                advancedSeoSuggestions.push('Failed to get advanced SEO suggestions from Gemini API.');
                            }
                            seoSuggestionsCombined.push(...advancedSeoSuggestions);

                            results.seoAnalysis = {
                                keywordPresence: seoKeywordPresence,
                                keywordDensity: seoKeywordDensity,
                                seoSuggestions: seoSuggestionsCombined,
                                message: 'SEO insights combine client-side checks and Gemini API for advanced suggestions.'
                            };

                        } catch (apiError) {
                            console.error("Gemini API error for SEO analysis:", apiError);
                            seoSuggestionsCombined.push(`API Error for advanced suggestions: ${apiError.message}`);
                            results.seoAnalysis = {
                                keywordPresence: seoKeywordPresence,
                                keywordDensity: seoKeywordDensity,
                                seoSuggestions: seoSuggestionsCombined,
                                message: 'SEO insights combine client-side checks and Gemini API for advanced suggestions.'
                            };
                        }
                    }

                    // 7. Blended Analysis (Client-side aggregation)
                    if (enableBlendedAnalysis) {
                        const qualityScore = calculateContentQualityScore({
                            wordCount: contentWordCount,
                            readabilityScore: contentReadabilityScore,
                            sentiment: linguisticSentiment,
                            keyTerms: wordEmbeddingKeyTerms,
                            complexity: linguisticComplexityAssessment
                        });
                        const optimizationScore = calculateOptimizationScore({
                            keywordDensity: seoKeywordDensity,
                            keywordPresence: seoKeywordPresence,
                            comprehensionLevel: comprehensionReadingLevel,
                            semanticSummary: wordEmbeddingSemanticSummary
                        });

                        results.blendedAnalysis = {
                            contentQualityScore: qualityScore,
                            optimizationScore: optimizationScore,
                            message: 'Overall content assessment based on combined metrics.'
                        };
                    }

                    // 8. Forecasting & Strategy (via Gemini API)
                    if (enableForecasting) {
                        try {
                            const chatHistory = [];
                            const prompt = `Based on the following content:
                            - Target Keyword: "${targetKeyword}"
                            - Word Count: ${contentWordCount}
                            - Readability Score (Flesch-Kincaid): ${contentReadabilityScore.toFixed(1)}
                            - Key Terms: ${wordEmbeddingKeyTerms}
                            - Sentiment: ${linguisticSentiment}
                            - Linguistic Complexity: ${linguisticComplexityAssessment}

                            What are the potential future impacts on SEO or user engagement based on this analysis, and what strategic next steps or content roadmap suggestions would you recommend for maximizing its performance? Focus on actionable insights. Respond in JSON with a 'predictedImpact' string and an array of 'strategicSuggestions'.`;

                            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                            const payload = {
                                contents: chatHistory,
                                generationConfig: {
                                    responseMimeType: "application/json",
                                    responseSchema: {
                                        type: "OBJECT",
                                        properties: {
                                            "predictedImpact": { "type": "STRING" },
                                            "strategicSuggestions": {
                                                type: "ARRAY",
                                                items: { "type": "STRING" }
                                            }
                                        },
                                        propertyOrdering: ["predictedImpact", "strategicSuggestions"]
                                    }
                                }
                            };
                            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                            const response = await fetch(apiUrl, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload)
                            });
                            const result = await response.json();

                            if (result.candidates && result.candidates.length > 0 &&
                                result.candidates[0].content && result.candidates[0].content.parts &&
                                result.candidates[0].content.parts.length > 0) {
                                const json = result.candidates[0].content.parts[0].text;
                                const parsedJson = JSON.parse(json);
                                results.forecasting = {
                                    predictedImpact: parsedJson.predictedImpact || 'N/A',
                                    strategicSuggestions: parsedJson.strategicSuggestions && parsedJson.strategicSuggestions.length > 0 ? parsedJson.strategicSuggestions : ['No specific suggestions.'],
                                    message: 'Future impact and strategy suggestions generated using Gemini API.'
                                };
                            } else {
                                results.forecasting = { predictedImpact: 'Error', strategicSuggestions: ['Error'], message: 'Failed to get results from Gemini API.' };
                            }
                        } catch (apiError) {
                            console.error("Gemini API error for forecasting:", apiError);
                            results.forecasting = { predictedImpact: 'Error', strategicSuggestions: [`API Error: ${apiError.message}`], message: `API Error: ${apiError.message}` };
                        }
                    }

                    // 9. Competitive Gap Analysis (via Gemini API)
                    if (enableCompetitiveGap) {
                        if (!comparisonText.trim()) {
                            results.competitiveGap = {
                                contentGaps: [],
                                improvementSuggestions: [],
                                uniqueStrengths: [],
                                message: 'Please provide competitor/ideal content for competitive gap analysis.'
                            };
                        } else {
                            try {
                                const chatHistory = [];
                                const prompt = `Compare the 'Your Content' and 'Competitor/Ideal Content' provided. Identify key content gaps in 'Your Content' relative to the 'Competitor/Ideal Content', and suggest ways to bridge these gaps. Also, identify any unique strengths or angles in 'Your Content' that could be leveraged. Respond in JSON with an array of 'contentGaps', an array of 'improvementSuggestions', and an array of 'uniqueStrengths'.
                                Your Content: "${textContent}"
                                Competitor/Ideal Content: "${comparisonText}"`;

                                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                                const payload = {
                                    contents: chatHistory,
                                    generationConfig: {
                                        responseMimeType: "application/json",
                                        responseSchema: {
                                            type: "OBJECT",
                                            properties: {
                                                "contentGaps": {
                                                    type: "ARRAY",
                                                    items: { "type": "STRING" }
                                                },
                                                "improvementSuggestions": {
                                                    type: "ARRAY",
                                                    items: { "type": "STRING" }
                                                },
                                                "uniqueStrengths": {
                                                    type: "ARRAY",
                                                    items: { "type": "STRING" }
                                                }
                                            },
                                            propertyOrdering: ["contentGaps", "improvementSuggestions", "uniqueStrengths"]
                                        }
                                    }
                                };
                                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                                const response = await fetch(apiUrl, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify(payload)
                                });
                                const result = await response.json();

                                if (result.candidates && result.candidates.length > 0 &&
                                    result.candidates[0].content && result.candidates[0].content.parts &&
                                    result.candidates[0].content.parts.length > 0) {
                                    const json = result.candidates[0].content.parts[0].text;
                                    const parsedJson = JSON.parse(json);
                                    results.competitiveGap = {
                                        contentGaps: parsedJson.contentGaps || [],
                                        improvementSuggestions: parsedJson.improvementSuggestions || [],
                                        uniqueStrengths: parsedJson.uniqueStrengths || [],
                                        message: 'Competitive gap analysis generated using Gemini API.'
                                    };
                                } else {
                                    results.competitiveGap = { contentGaps: [], improvementSuggestions: [], uniqueStrengths: [], message: 'Failed to get results from Gemini API.' };
                                }
                            } catch (apiError) {
                                console.error("Gemini API error for competitive gap:", apiError);
                                results.competitiveGap = { contentGaps: [], improvementSuggestions: [], uniqueStrengths: [], message: `API Error: ${apiError.message}` };
                            }
                        }
                    }

                    setAnalysisResults(results);

                } catch (err) {
                    console.error("Analysis error:", err);
                    setError("An error occurred during analysis. Please try again.");
                } finally {
                    setIsLoading(false);
                }
            };

            // --- Client-Side Analysis Functions ---

            // Calculate Bag-of-Words Similarity
            const calculateBagOfWordsSimilarity = (text1, text2) => {
                const words1 = new Set(text1.toLowerCase().match(/\b\w+\b/g) || []);
                const words2 = new Set(text2.toLowerCase().match(/\b\w+\b/g) || []);
                const intersection = new Set([...words1].filter(x => words2.has(x)));
                const union = new Set([...words1, ...words2]);

                if (union.size === 0) return 0;
                return (intersection.size / union.size) * 100;
            };

            // Perform basic client-side linguistic analysis (avg sentence/word length)
            const performClientSideLinguisticAnalysis = (text) => {
                const sentences = text.split(/[.!?]\s*/).filter(s => s.trim().length > 0);
                const words = text.match(/\b\w+\b/g) || [];
                const totalWordLength = words.reduce((sum, word) => sum + word.length, 0);

                const avgSentenceLength = sentences.length > 0 ? (words.length / sentences.length).toFixed(0) : 0;
                const avgWordLength = words.length > 0 ? (totalWordLength / words.length) : 0;

                return { avgSentenceLength, avgWordLength };
            };

            // Perform Content Analysis (Word count, sentence count, paragraph count, Flesch-Kincaid readability)
            const performContentAnalysis = (text) => {
                const words = text.match(/\b\w+\b/g) || [];
                const sentences = text.split(/[.!?]\s*/).filter(s => s.trim().length > 0);
                const paragraphs = text.split(/\n\s*\n/).filter(p => p.trim().length > 0);

                // Flesch-Kincaid Readability Formula
                // 0.39 * (words / sentences) + 11.8 * (syllables / words) - 15.59
                // Approximating syllables: count vowels as primary indicator, adjust for common patterns.
                const countSyllables = (word) => {
                    word = word.toLowerCase();
                    if (word.length === 0) return 0;
                    let count = 0;
                    const vowels = 'aeiouy';
                    if (vowels.includes(word[0])) {
                        count++;
                    }
                    for (let i = 1; i < word.length; i++) {
                        if (vowels.includes(word[i]) && !vowels.includes(word[i - 1])) {
                            count++;
                        }
                    }
                    if (word.endsWith('e')) {
                        count--;
                    }
                    if (word.endsWith('le') && word.length > 2 && !vowels.includes(word[word.length - 3])) {
                        count++;
                    }
                    return Math.max(1, count); // Ensure at least 1 syllable per word
                };

                const totalSyllables = words.reduce((sum, word) => sum + countSyllables(word), 0);

                const avgWordsPerSentence = sentences.length > 0 ? (words.length / sentences.length) : 0;
                const avgSyllablesPerWord = words.length > 0 ? (totalSyllables / words.length) : 0;

                const readabilityScore = 0.39 * avgWordsPerSentence + 11.8 * avgSyllablesPerWord - 15.59;

                return {
                    wordCount: words.length,
                    sentenceCount: sentences.length,
                    paragraphCount: paragraphs.length,
                    readabilityScore: Math.max(0, readabilityScore) // Ensure score is not negative
                };
            };

            // Perform client-side SEO Analysis (keyword density, basic suggestions)
            const performSeoAnalysis = (text, keyword) => {
                const words = text.toLowerCase().match(/\b\w+\b/g) || [];
                const keywordLower = keyword.toLowerCase();
                const keywordOccurrences = words.filter(word => word === keywordLower).length;
                const totalWords = words.length;

                let keywordDensity = null;
                if (totalWords > 0 && keywordLower) {
                    keywordDensity = (keywordOccurrences / totalWords) * 100;
                }

                const clientSideSeoSug = [];
                let keywordPresence = 'Not detected';

                if (keywordLower && keywordOccurrences > 0) {
                    keywordPresence = `Detected (${keywordOccurrences} times)`;
                    if (keywordDensity < 1 || keywordDensity > 3) {
                        clientSideSeoSug.push(`Adjust keyword density for "${keyword}" (currently ${keywordDensity.toFixed(2)}%). Aim for 1-3%.`);
                    }
                } else if (keywordLower) {
                    clientSideSeoSug.push(`Consider including the target keyword "${keyword}" in your content.`);
                }

                if (text.length < 500) {
                    clientSideSeoSug.push('Content might be too short for comprehensive SEO. Aim for more depth (e.g., 800+ words).');
                }
                clientSideSeoSug.push('Ensure a clear H1 tag is present and unique (check your page source).');
                clientSideSeoSug.push('Optimize your meta description to be concise and compelling for click-through rate (CTR).');
                clientSideSeoSug.push('Include relevant internal links to other authoritative pages on your site.');
                clientSideSeoSug.push('Include high-quality external links to reputable sources.');
                clientSideSeoSug.push('Use descriptive alt text for all images to improve accessibility and SEO.');

                return { keywordDensity, keywordPresence, clientSideSeoSug };
            };

            // Calculate Content Quality Score (Client-side blended analysis)
            const calculateContentQualityScore = (metrics) => {
                let score = 0;
                // Readability: Higher is generally better for accessibility
                if (metrics.readabilityScore >= 60) score += 20; // Easy to read
                else if (metrics.readabilityScore >= 30) score += 10; // Readable
                else score += 5; // Difficult

                // Sentiment: Positive is often desired for content
                if (metrics.sentiment === 'Positive') score += 15;
                else if (metrics.sentiment === 'Neutral') score += 10;
                else score += 5;

                // Word Count: Adequate length
                if (metrics.wordCount >= 800) score += 20;
                else if (metrics.wordCount >= 400) score += 10;
                else score += 5;

                // Key Terms: Presence indicates relevance
                if (metrics.keyTerms !== 'N/A' && metrics.keyTerms.length > 0) score += 15;

                // Complexity: Balanced complexity can be good
                if (metrics.complexity === 'Moderate') score += 10;
                else if (metrics.complexity === 'Simple') score += 5;

                // Normalize to a 0-100 scale (rough estimate)
                return Math.min(100, Math.max(0, score * 100 / 80)).toFixed(0); // Max possible raw score ~80
            };

            // Calculate Optimization Score (Client-side blended analysis)
            const calculateOptimizationScore = (metrics) => {
                let score = 0;

                // Keyword Density: Optimal range
                const kd = parseFloat(metrics.keywordDensity);
                if (!isNaN(kd) && kd >= 1 && kd <= 3) score += 20;
                else if (!isNaN(kd) && ((kd > 0.5 && kd < 1) || (kd > 3 && kd < 5))) score += 10;

                // Keyword Presence
                if (metrics.keywordPresence.includes('Detected')) score += 15;

                // Comprehension Level: Aligned with target audience
                if (metrics.comprehensionLevel === 'Middle School' || metrics.comprehensionLevel === 'High School / College') score += 15; // Assuming general audience
                else if (metrics.comprehensionLevel === 'Elementary School') score += 5;

                // Semantic Summary indicates relevant content
                if (metrics.semanticSummary !== 'N/A' && metrics.semanticSummary.length > 0) score += 10;

                // Normalize to a 0-100 scale
                return Math.min(100, Math.max(0, score * 100 / 60)).toFixed(0); // Max possible raw score ~60
            };


            return (
                <div className="min-h-screen bg-gradient-to-br from-purple-50 to-indigo-100 flex items-center justify-center p-4 font-inter">
                    <div className="w-full max-w-4xl bg-white rounded-xl shadow-2xl p-8 space-y-8">
                        {/* Header with Profile/Sign Out */}
                        <div className="flex justify-between items-center mb-6">
                            <div className="text-xl font-semibold text-gray-700">
                                Welcome, {username}
                            </div>
                            <button
                                onClick={() => setIsEditingProfile(!isEditingProfile)}
                                className="px-4 py-2 rounded-lg bg-purple-500 text-white hover:bg-purple-600 transition-colors duration-200 shadow-md"
                            >
                                {isEditingProfile ? 'Back to Analyzer' : 'Profile Settings'}
                            </button>
                        </div>

                        {/* Conditional Rendering based on Auth State and Profile Editing */}
                        {!isAuthReady ? (
                            <LoadingSpinner />
                        ) : isEditingProfile ? (
                            <ProfileScreen
                                user={user}
                                username={username}
                                setUsername={setUsername}
                                setIsEditingProfile={setIsEditingProfile}
                                saveUserProfile={saveUserProfile}
                                handleSignOut={handleSignOut}
                                isSaving={isSavingProfile}
                            />
                        ) : (
                            <>
                                {/* Title and Description */}
                                <div className="text-center">
                                    <h1 className="text-4xl font-bold text-purple-800 mb-2">Content Insight Engine</h1>
                                    <p className="text-lg text-gray-600">Analyze your content for optimization, readability, and SEO effectiveness.</p>
                                </div>

                                {/* Input Section */}
                                <div className="space-y-4">
                                    <label htmlFor="textContent" className="block text-xl font-semibold text-gray-700">Your Content:</label>
                                    <textarea
                                        id="textContent"
                                        className="w-full p-4 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent transition duration-200 resize-y min-h-[150px] shadow-sm"
                                        placeholder="Paste your article, blog post, or any text here for analysis..."
                                        value={textContent}
                                        onChange={(e) => setTextContent(e.target.value)}
                                    ></textarea>

                                    <label htmlFor="comparisonText" className="block text-xl font-semibold text-gray-700">Competitor/Ideal Content (for Comparison & Gap Analysis):</label>
                                    <textarea
                                        id="comparisonText"
                                        className="w-full p-4 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent transition duration-200 resize-y min-h-[100px] shadow-sm"
                                        placeholder="Paste content here to compare for similarity and identify gaps (e.g., competitor's article, ideal content)..."
                                        value={comparisonText}
                                        onChange={(e) => setComparisonText(e.target.value)}
                                    ></textarea>

                                    <label htmlFor="targetKeyword" className="block text-xl font-semibold text-gray-700">Target Keyword (for SEO & Forecasting Analysis):</label>
                                    <input
                                        type="text"
                                        id="targetKeyword"
                                        className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent transition duration-200 shadow-sm"
                                        placeholder="Enter your primary target keyword (e.g., 'advanced SEO tools')"
                                        value={targetKeyword}
                                        onChange={(e) => setTargetKeyword(e.target.value)}
                                    />
                                </div>

                                {/* Analysis Options */}
                                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                                    <div className="flex items-center">
                                        <input
                                            type="checkbox"
                                            id="cosineSimilarity"
                                            className="h-5 w-5 text-purple-600 rounded focus:ring-purple-500"
                                            checked={enableCosineSimilarity}
                                            onChange={(e) => setEnableCosineSimilarity(e.target.checked)}
                                        />
                                        <label htmlFor="cosineSimilarity" className="ml-2 text-gray-700">Cosine Similarity (Bag-of-Words)</label>
                                    </div>
                                    <div className="flex items-center">
                                        <input
                                            type="checkbox"
                                            id="wordEmbedding"
                                            className="h-5 w-5 text-purple-600 rounded focus:ring-purple-500"
                                            checked={enableWordEmbedding}
                                            onChange={(e) => setEnableWordEmbedding(e.target.checked)}
                                        />
                                        <label htmlFor="wordEmbedding" className="ml-2 text-gray-700">Word Embedding Analysis (via API)</label>
                                    </div>
                                    <div className="flex items-center">
                                        <input
                                            type="checkbox"
                                            id="linguisticAnalytics"
                                            className="h-5 w-5 text-purple-600 rounded focus:ring-purple-500"
                                            checked={enableLinguisticAnalytics}
                                            onChange={(e) => setEnableLinguisticAnalytics(e.target.checked)}
                                        />
                                        <label htmlFor="linguisticAnalytics" className="ml-2 text-gray-700">Linguistic Analytics (via API)</label>
                                    </div>
                                    <div className="flex items-center">
                                        <input
                                            type="checkbox"
                                            id="contentAnalysis"
                                            className="h-5 w-5 text-purple-600 rounded focus:ring-purple-500"
                                            checked={enableContentAnalysis}
                                            onChange={(e) => setEnableContentAnalysis(e.target.checked)}
                                        />
                                        <label htmlFor="contentAnalysis" className="ml-2 text-gray-700">Content Analysis (Client-side)</label>
                                    </div>
                                    <div className="flex items-center">
                                        <input
                                            type="checkbox"
                                            id="comprehensionAnalysis"
                                            className="h-5 w-5 text-purple-600 rounded focus:ring-purple-500"
                                            checked={enableComprehensionAnalysis}
                                            onChange={(e) => setEnableComprehensionAnalysis(e.target.checked)}
                                        />
                                        <label htmlFor="comprehensionAnalysis" className="ml-2 text-gray-700">Comprehension Analysis (via API)</label>
                                    </div>
                                    <div className="flex items-center">
                                        <input
                                            type="checkbox"
                                            id="seoAnalysis"
                                            className="h-5 w-5 text-purple-600 rounded focus:ring-purple-500"
                                            checked={enableSeoAnalysis}
                                            onChange={(e) => setEnableSeoAnalysis(e.target.checked)}
                                        />
                                        <label htmlFor="seoAnalysis" className="ml-2 text-gray-700">SEO Analysis (Mixed)</label>
                                    </div>
                                    {/* New Checkboxes */}
                                    <div className="flex items-center">
                                        <input
                                            type="checkbox"
                                            id="blendedAnalysis"
                                            className="h-5 w-5 text-purple-600 rounded focus:ring-purple-500"
                                            checked={enableBlendedAnalysis}
                                            onChange={(e) => setEnableBlendedAnalysis(e.target.checked)}
                                        />
                                        <label htmlFor="blendedAnalysis" className="ml-2 text-gray-700">Deeper Blended Analysis</label>
                                    </div>
                                    <div className="flex items-center">
                                        <input
                                            type="checkbox"
                                            id="forecasting"
                                            className="h-5 w-5 text-purple-600 rounded focus:ring-purple-500"
                                            checked={enableForecasting}
                                            onChange={(e) => setEnableForecasting(e.target.checked)}
                                        />
                                        <label htmlFor="forecasting" className="ml-2 text-gray-700">Forecasting & Strategy (via API)</label>
                                    </div>
                                    <div className="flex items-center">
                                        <input
                                            type="checkbox"
                                            id="competitiveGap"
                                            className="h-5 w-5 text-purple-600 rounded focus:ring-purple-500"
                                            checked={enableCompetitiveGap}
                                            onChange={(e) => setEnableCompetitiveGap(e.target.checked)}
                                        />
                                        <label htmlFor="competitiveGap" className="ml-2 text-gray-700">Competitive Gap Analysis (via API)</label>
                                    </div>
                                </div>

                                {/* Action Button */}
                                <button
                                    onClick={performAnalysis}
                                    className={`w-full py-4 rounded-xl font-bold text-lg text-white transition-all duration-300 shadow-lg
                                                ${isLoading
                                                ? 'bg-gray-400 cursor-not-allowed'
                                                : 'bg-gradient-to-r from-purple-600 to-indigo-700 hover:from-purple-700 hover:to-indigo-800 transform hover:scale-105'
                                                }`}
                                    disabled={isLoading}
                                >
                                    {isLoading ? 'Analyzing Content...' : 'Analyze Content'}
                                </button>

                                {/* Error Message */}
                                {error && (
                                    <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative shadow-md" role="alert">
                                        <strong className="font-bold">Error!</strong>
                                        <span className="block sm:inline ml-2">{error}</span>
                                    </div>
                                )}

                                {/* Results Section */}
                                {analysisResults && (
                                    <div className="bg-white p-6 rounded-xl shadow-inner border border-gray-200">
                                        <h2 className="text-3xl font-bold text-purple-800 mb-6 text-center">Analysis Results</h2>

                                        {analysisResults.blendedAnalysis && (
                                            <AnalysisResultDisplay
                                                title="Deeper Blended Analysis"
                                                results={{
                                                    'Content Quality Score': `${analysisResults.blendedAnalysis.contentQualityScore}/100`,
                                                    'Optimization Score': `${analysisResults.blendedAnalysis.optimizationScore}/100`
                                                }}
                                                message={analysisResults.blendedAnalysis.message}
                                                colorClass="text-purple-700"
                                                bgColorClass="bg-purple-50"
                                            />
                                        )}

                                        {analysisResults.forecasting && (
                                            <AnalysisResultDisplay
                                                title="Forecasting & Strategy"
                                                results={{
                                                    'Predicted Impact': analysisResults.forecasting.predictedImpact,
                                                    'Strategic Suggestions': analysisResults.forecasting.strategicSuggestions
                                                }}
                                                message={analysisResults.forecasting.message}
                                                colorClass="text-blue-700"
                                                bgColorClass="bg-blue-50"
                                            />
                                        )}

                                        {analysisResults.competitiveGap && (
                                            <AnalysisResultDisplay
                                                title="Competitive Gap Analysis"
                                                results={{
                                                    'Content Gaps Identified': analysisResults.competitiveGap.contentGaps,
                                                    'Improvement Suggestions': analysisResults.competitiveGap.improvementSuggestions,
                                                    'Unique Strengths/Leverage Points': analysisResults.competitiveGap.uniqueStrengths
                                                }}
                                                message={analysisResults.competitiveGap.message}
                                                colorClass="text-green-700"
                                                bgColorClass="bg-green-50"
                                            />
                                        )}

                                        {/* Existing Analysis Sections remain below */}
                                        {analysisResults.cosineSimilarity && (
                                            <AnalysisResultDisplay
                                                title="Cosine Similarity"
                                                results={analysisResults.cosineSimilarity}
                                                message={analysisResults.cosineSimilarity.message}
                                            />
                                        )}

                                        {analysisResults.wordEmbedding && (
                                            <AnalysisResultDisplay
                                                title="Word Embedding Analysis"
                                                results={analysisResults.wordEmbedding}
                                                message={analysisResults.wordEmbedding.message}
                                            />
                                        )}

                                        {analysisResults.linguisticAnalytics && (
                                            <AnalysisResultDisplay
                                                title="Linguistic Analytics"
                                                results={analysisResults.linguisticAnalytics}
                                                message={analysisResults.linguisticAnalytics.message}
                                            />
                                        )}

                                        {analysisResults.contentAnalysis && (
                                            <AnalysisResultDisplay
                                                title="Content Analysis"
                                                results={analysisResults.contentAnalysis}
                                                message={analysisResults.contentAnalysis.message}
                                            />
                                        )}

                                        {analysisResults.comprehensionAnalysis && (
                                            <AnalysisResultDisplay
                                                title="Comprehension Analysis"
                                                results={analysisResults.comprehensionAnalysis}
                                                message={analysisResults.comprehensionAnalysis.message}
                                            />
                                        )}

                                        {analysisResults.seoAnalysis && (
                                            <AnalysisResultDisplay
                                                title="SEO Analysis"
                                                results={{
                                                    'Target Keyword': targetKeyword || 'N/A',
                                                    'Keyword Presence': analysisResults.seoAnalysis.keywordPresence,
                                                    'Keyword Density': analysisResults.seoAnalysis.keywordDensity,
                                                    'SEO Suggestions': analysisResults.seoAnalysis.seoSuggestions
                                                }}
                                                message={analysisResults.seoAnalysis.message}
                                            />
                                        )}

                                        {Object.keys(analysisResults).length === 0 && (
                                            <p className="text-gray-600 text-center">No analysis types selected or content provided.</p>
                                        )}
                                    </div>
                                )}
                            </>
                        )}
                    </div>
                </div>
            );
        };

        // Render the App component into the 'root' div
        // Using createRoot for React 18 compatibility
        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<App />);
    </script>
</body>
</html>
